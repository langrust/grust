(* #"/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 5 0 56 1 *)

(* AccState *)

let%span slib0 = "/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 40 20 40 21
let%span slib1 = "/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 41 48 41 49
let%span slib2 = "/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 41 51 41 52
let%span slib3 = "/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 5 0 56 1
let%span slib4 = "/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 5 0 56 1
let%span sresolve5 = "/home/thome/Documents/git/langrust/grustine/creusot/creusot-contracts/src/resolve.rs" 54 20 54 34

use creusot.int.Int64

type t_AccInput'0  =
  { t_AccInput__c'0: bool; t_AccInput__d'0: Int64.t; t_AccInput__v'0: Int64.t; t_AccInput__s'0: Int64.t }

use creusot.prelude.MutBorrow

predicate resolve'1 (self : MutBorrow.t ()) =
  [%#sresolve5] self.final = self.current

predicate resolve'0 (_1 : MutBorrow.t ()) =
  resolve'1 _1

use creusot.int.Int64

use mach.int.Int

function safety_distance'1 [#"/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 5 0 56 1] (sv_v : int) (fv_v : int) : int

 =
  [%#slib4] let sv_d_stop = sv_v * 1 + Int.div (sv_v * sv_v) (2 * 6) in let fv_d_stop = Int.div (fv_v * fv_v) (2
  * 6) in sv_d_stop - fv_d_stop

let rec safety_distance'0 (sv_v:Int64.t) (fv_v:Int64.t) (return'  (ret:Int64.t))= {[@expl:safety_distance requires #0] [%#slib3] 0
  < Int64.to_int sv_v
  /\ Int64.to_int sv_v <= 50}
  {[@expl:safety_distance requires #1] [%#slib3] 0 < Int64.to_int fv_v
  /\ Int64.to_int fv_v < Int64.to_int sv_v /\ Int64.to_int sv_v - Int64.to_int fv_v <= 10}
  any
  [ return' (result:Int64.t)-> {[%#slib3] 0 < Int64.to_int result /\ Int64.to_int result < 150}
    {[%#slib3] Int64.to_int result = safety_distance'1 (Int64.to_int sv_v) (Int64.to_int fv_v)}
    (! return' {result}) ]


function compute_braking'1 [#"/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 5 0 56 1] (d_grace : int) (v : int) : int

 =
  [%#slib3] Int.div (v * v) (2 * d_grace)

let rec compute_braking'0 (d_grace:Int64.t) (v:Int64.t) (return'  (ret:Int64.t))= {[@expl:compute_braking requires #0] [%#slib3] 0
  < Int64.to_int d_grace
  /\ Int64.to_int d_grace < 150 /\ Int64.to_int v < 0 /\ - Int64.to_int v <= 10}
  {[@expl:compute_braking requires #1] [%#slib3] Int64.to_int d_grace
  > Int.div (Int64.to_int v * Int64.to_int v) (2 * 6)}
  any
  [ return' (result:Int64.t)-> {[%#slib3] 0 <= Int64.to_int result /\ Int64.to_int result <= 6}
    {[%#slib3] Int64.to_int result = compute_braking'1 (Int64.to_int d_grace) (Int64.to_int v)}
    (! return' {result}) ]


use creusot.prelude.Intrinsic

meta "compute_max_steps" 1000000

let rec step'0[#"/home/thome/Documents/git/langrust/grustine/examples/acc_fmics_greusot/src/lib.rs" 5 0 56 1] (self:MutBorrow.t ()) (input:t_AccInput'0) (return'  (ret:Int64.t))= {[@expl:step requires #0] [%#slib3] Int64.to_int input.t_AccInput__d'0
  < 150}
  {[@expl:step requires #1] [%#slib3] input.t_AccInput__c'0
   -> 0 < Int64.to_int input.t_AccInput__s'0
  /\ Int64.to_int input.t_AccInput__s'0 <= 50
  /\ 0 < Int64.to_int input.t_AccInput__s'0 + Int64.to_int input.t_AccInput__v'0
  /\ Int64.to_int input.t_AccInput__v'0 < 0 /\ - Int64.to_int input.t_AccInput__v'0 <= 10}
  {[@expl:step requires #2] [%#slib3] input.t_AccInput__c'0
   -> Int64.to_int input.t_AccInput__d'0
  - safety_distance'1 (Int64.to_int input.t_AccInput__s'0) (Int64.to_int input.t_AccInput__s'0
  + Int64.to_int input.t_AccInput__v'0)
  > Int.div (Int64.to_int input.t_AccInput__v'0 * Int64.to_int input.t_AccInput__v'0) (2 * 6)}
  (! bb0
  [ bb0 = s0
    [ s0 = -{resolve'0 self}- s1
    | s1 = any [ br0 -> {input.t_AccInput__c'0 = false} (! bb2) | br1 -> {input.t_AccInput__c'0} (! bb1) ]  ]
  
  | bb1 = bb3
  | bb3 = s0
    [ s0 = Int64.add {input.t_AccInput__s'0} {input.t_AccInput__v'0} (fun (_ret':Int64.t) ->  [ &fv_v1 <- _ret' ] s1)
    | s1 = safety_distance'0 {input.t_AccInput__s'0} {fv_v1} (fun (_ret':Int64.t) ->  [ &d_safe1 <- _ret' ] s2)
    | s2 = bb4 ]
  
  | bb4 = s0
    [ s0 = Int64.sub {input.t_AccInput__d'0} {d_safe1} (fun (_ret':Int64.t) ->  [ &_18 <- _ret' ] s1)
    | s1 = compute_braking'0 {_18} {input.t_AccInput__v'0} (fun (_ret':Int64.t) ->  [ &b1 <- _ret' ] s2)
    | s2 = bb5 ]
  
  | bb5 = s0 [ s0 =  [ &_10 <- (d_safe1, b1, fv_v1) ] s1 | s1 = bb6 ] 
  | bb2 = s0
    [ s0 =  [ &b2 <- [%#slib0] (0 : Int64.t) ] s1
    | s1 =  [ &_28 <- (([%#slib1] (0 : Int64.t)), ([%#slib2] (0 : Int64.t))) ] s2
    | s2 =  [ &fv_v2 <- let (r'0, _) = _28 in r'0 ] s3
    | s3 =  [ &d_safe2 <- let (_, r'1) = _28 in r'1 ] s4
    | s4 =  [ &_10 <- (d_safe2, b2, fv_v2) ] s5
    | s5 = bb6 ]
  
  | bb6 = s0
    [ s0 =  [ &d_safe <- let (r'0, _, _) = _10 in r'0 ] s1
    | s1 =  [ &b <- let (_, r'1, _) = _10 in r'1 ] s2
    | s2 =  [ &fv_v <- let (_, _, r'2) = _10 in r'2 ] s3
    | s3 =  [ &_0 <- b ] s4
    | s4 = return' {_0} ]
   ]
  )
  [ & _0 : Int64.t = Intrinsic.any_l ()
  | & self : MutBorrow.t () = self
  | & input : t_AccInput'0 = input
  | & d_safe : Int64.t = Intrinsic.any_l ()
  | & b : Int64.t = Intrinsic.any_l ()
  | & fv_v : Int64.t = Intrinsic.any_l ()
  | & _10 : (Int64.t, Int64.t, Int64.t) = Intrinsic.any_l ()
  | & fv_v1 : Int64.t = Intrinsic.any_l ()
  | & d_safe1 : Int64.t = Intrinsic.any_l ()
  | & b1 : Int64.t = Intrinsic.any_l ()
  | & _18 : Int64.t = Intrinsic.any_l ()
  | & b2 : Int64.t = Intrinsic.any_l ()
  | & fv_v2 : Int64.t = Intrinsic.any_l ()
  | & d_safe2 : Int64.t = Intrinsic.any_l ()
  | & _28 : (Int64.t, Int64.t) = Intrinsic.any_l () ]
  
  [ return' (result:Int64.t)-> {[@expl:step ensures] [%#slib3] 0 <= Int64.to_int result /\ Int64.to_int result <= 6}
    (! return' {result}) ]
  
