#[derive(Clone, Copy, PartialEq, Default)]
pub struct Hysterisis {
    pub value: f64,
    pub flag: bool,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum ActivationRequest {
    #[default]
    Off,
    On,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum VdcState {
    #[default]
    On,
    Off,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum VacuumBrakeState {
    #[default]
    BelowMinLevel,
    AboveMinLevel,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum Kickdown {
    #[default]
    Deactivated,
    Activated,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum Failure {
    #[default]
    Entering,
    Recovered,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum SpeedLimiter {
    #[default]
    Off,
    On,
    Fail,
}
#[derive(Clone, Copy, PartialEq, Default)]
pub enum SpeedLimiterOn {
    #[default]
    StandBy,
    Actif,
    OverrideVoluntary,
}
pub fn new_hysterisis(value: f64) -> Hysterisis {
    Hysterisis {
        value: value,
        flag: true,
    }
}
pub fn update_hysterisis(prev_hyst: Hysterisis, speed: f64, v_set: f64) -> Hysterisis {
    let activation_threshold = v_set * 0.99f64;
    let deactivation_threshold = v_set * 0.98f64;
    let flag = if prev_hyst.flag && (speed <= deactivation_threshold) {
        false
    } else {
        if !(prev_hyst.flag) && (speed >= activation_threshold) {
            true
        } else {
            prev_hyst.flag
        }
    };
    let new_hysterisis = Hysterisis {
        value: speed,
        flag: flag,
    };
    new_hysterisis
}
pub fn in_regulation(hysterisis: Hysterisis) -> bool {
    hysterisis.flag
}
pub fn into_diagnostic(to_be_defined: i64) -> i64 {
    to_be_defined
}
pub fn threshold_set_speed(set_speed: f64) -> f64 {
    let ceiled_speed = if set_speed > 150.0f64 {
        150.0f64
    } else {
        set_speed
    };
    let grounded_speed = if set_speed < 10.0f64 {
        10.0f64
    } else {
        ceiled_speed
    };
    grounded_speed
}
pub fn activation_condition(vacuum_brake_state: VacuumBrakeState, v_set: f64) -> bool {
    (vacuum_brake_state != VacuumBrakeState::BelowMinLevel) && (v_set > 0.0f64)
}
pub fn standby_condition(vacuum_brake_state: VacuumBrakeState, v_set: f64) -> bool {
    (vacuum_brake_state == VacuumBrakeState::BelowMinLevel) || (v_set <= 0.0f64)
}
pub struct ProcessSetSpeedInput {
    pub set_speed: Option<f64>,
}
pub struct ProcessSetSpeedState {
    last_v_set: f64,
}
impl ProcessSetSpeedState {
    pub fn init() -> ProcessSetSpeedState {
        ProcessSetSpeedState { last_v_set: 0.0f64 }
    }
    pub fn step(&mut self, input: ProcessSetSpeedInput) -> (f64, bool) {
        let prev_v_set = self.last_v_set;
        let v_set = match (input.set_speed) {
            (Some(v)) => threshold_set_speed(v),
            (_) => self.last_v_set,
        };
        let v_update = prev_v_set != v_set;
        self.last_v_set = v_set;
        (v_set, v_update)
    }
}
pub struct SpeedLimiterOnInput {
    pub prev_on_state: SpeedLimiterOn,
    pub vacuum_brake_state: VacuumBrakeState,
    pub kickdown: Option<Kickdown>,
    pub speed: f64,
    pub v_set: f64,
}
pub struct SpeedLimiterOnState {
    last_hysterisis: Hysterisis,
    last_kickdown_state: Kickdown,
}
impl SpeedLimiterOnState {
    pub fn init() -> SpeedLimiterOnState {
        SpeedLimiterOnState {
            last_hysterisis: new_hysterisis(0.0f64),
            last_kickdown_state: Kickdown::Deactivated,
        }
    }
    pub fn step(&mut self, input: SpeedLimiterOnInput) -> (SpeedLimiterOn, bool, bool) {
        let prev_hysterisis = self.last_hysterisis;
        let kickdown_state = match (input.kickdown) {
            (Some(Kickdown::Activated)) if input.prev_on_state == SpeedLimiterOn::Actif => {
                Kickdown::Activated
            }
            (Some(Kickdown::Deactivated)) => Kickdown::Deactivated,
            (_) => self.last_kickdown_state,
        };
        let (hysterisis, on_state) = match input.prev_on_state {
            _ if kickdown_state == Kickdown::Activated => {
                let on_state = SpeedLimiterOn::OverrideVoluntary;
                let hysterisis = prev_hysterisis;
                (hysterisis, on_state)
            }
            SpeedLimiterOn::StandBy
                if activation_condition(input.vacuum_brake_state, input.v_set) =>
            {
                let on_state = SpeedLimiterOn::Actif;
                let hysterisis = new_hysterisis(0.0f64);
                (hysterisis, on_state)
            }
            SpeedLimiterOn::OverrideVoluntary if input.speed <= input.v_set => {
                let on_state = SpeedLimiterOn::Actif;
                let hysterisis = new_hysterisis(0.0f64);
                (hysterisis, on_state)
            }
            SpeedLimiterOn::Actif if standby_condition(input.vacuum_brake_state, input.v_set) => {
                let on_state = SpeedLimiterOn::StandBy;
                let hysterisis = prev_hysterisis;
                (hysterisis, on_state)
            }
            SpeedLimiterOn::Actif => {
                let on_state = input.prev_on_state;
                let hysterisis = update_hysterisis(prev_hysterisis, input.speed, input.v_set);
                (hysterisis, on_state)
            }
            _ => {
                let on_state = input.prev_on_state;
                let hysterisis = prev_hysterisis;
                (hysterisis, on_state)
            }
        };
        let state_update = input.prev_on_state != on_state;
        let in_reg = in_regulation(hysterisis);
        self.last_hysterisis = hysterisis;
        self.last_kickdown_state = kickdown_state;
        (on_state, in_reg, state_update)
    }
}
pub struct SpeedLimiterInput {
    pub activation_req: Option<ActivationRequest>,
    pub vacuum_brake_state: VacuumBrakeState,
    pub kickdown: Option<Kickdown>,
    pub failure: Option<Failure>,
    pub vdc_disabled: VdcState,
    pub speed: f64,
    pub v_set: f64,
}
pub struct SpeedLimiterState {
    last_on_state: SpeedLimiterOn,
    last_state: SpeedLimiter,
    speed_limiter_on: SpeedLimiterOnState,
}
impl SpeedLimiterState {
    pub fn init() -> SpeedLimiterState {
        SpeedLimiterState {
            last_on_state: Default::default(),
            last_state: SpeedLimiter::Off,
            speed_limiter_on: SpeedLimiterOnState::init(),
        }
    }
    pub fn step(&mut self, input: SpeedLimiterInput) -> (SpeedLimiter, SpeedLimiterOn, bool, bool) {
        let prev_state = self.last_state;
        let prev_on_state = self.last_on_state;
        let state = match (input.activation_req, input.failure) {
            (Some(activation_req), _) if activation_req == ActivationRequest::Off => {
                SpeedLimiter::Off
            }
            (Some(ActivationRequest::On), _) if prev_state == SpeedLimiter::Off => SpeedLimiter::On,
            (_, Some(failure)) if failure == Failure::Entering => SpeedLimiter::Fail,
            (_, Some(f)) if (f == Failure::Recovered) && (prev_state == SpeedLimiter::Fail) => {
                SpeedLimiter::On
            }
            (_, _) => self.last_state,
        };
        let (state_update, on_state, in_regulation) = match prev_state {
            SpeedLimiter::On => {
                let (on_state, in_regulation, state_update) =
                    self.speed_limiter_on.step(SpeedLimiterOnInput {
                        prev_on_state: prev_on_state,
                        vacuum_brake_state: input.vacuum_brake_state,
                        kickdown: input.kickdown,
                        speed: input.speed,
                        v_set: input.v_set,
                    });
                (state_update, on_state, in_regulation)
            }
            _ => {
                let on_state = SpeedLimiterOn::StandBy;
                let in_regulation = false;
                let state_update = prev_state != state;
                (state_update, on_state, in_regulation)
            }
        };
        self.last_on_state = on_state;
        self.last_state = state;
        (state, on_state, in_regulation, state_update)
    }
}
pub mod runtime {
    use super::*;
    use futures::{sink::SinkExt, stream::StreamExt};
    use RuntimeInput as I;
    use RuntimeOutput as O;
    use RuntimeTimer as T;
    #[derive(PartialEq)]
    pub enum RuntimeTimer {
        PeriodSpeedLimiter,
        PeriodInRegulation,
        DelaySpeedLimiter,
        TimeoutSpeedLimiter,
    }
    impl timer_stream::Timing for RuntimeTimer {
        fn get_duration(&self) -> std::time::Duration {
            match self {
                T::PeriodSpeedLimiter => std::time::Duration::from_millis(10u64),
                T::PeriodInRegulation => std::time::Duration::from_millis(10u64),
                T::DelaySpeedLimiter => std::time::Duration::from_millis(10u64),
                T::TimeoutSpeedLimiter => std::time::Duration::from_millis(500u64),
            }
        }
        fn do_reset(&self) -> bool {
            match self {
                T::PeriodSpeedLimiter => false,
                T::PeriodInRegulation => false,
                T::DelaySpeedLimiter => true,
                T::TimeoutSpeedLimiter => true,
            }
        }
    }
    pub enum RuntimeInput {
        Speed(f64, std::time::Instant),
        Kickdown(Kickdown, std::time::Instant),
        SetSpeed(f64, std::time::Instant),
        Vdc(VdcState, std::time::Instant),
        VacuumBrake(VacuumBrakeState, std::time::Instant),
        Activation(ActivationRequest, std::time::Instant),
        Failure(Failure, std::time::Instant),
        Timer(T, std::time::Instant),
    }
    impl priority_stream::Reset for RuntimeInput {
        fn do_reset(&self) -> bool {
            match self {
                I::Timer(timer, _) => timer_stream::Timing::do_reset(timer),
                _ => false,
            }
        }
    }
    impl PartialEq for RuntimeInput {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (I::Speed(this, _), I::Speed(other, _)) => this.eq(other),
                (I::Kickdown(this, _), I::Kickdown(other, _)) => this.eq(other),
                (I::SetSpeed(this, _), I::SetSpeed(other, _)) => this.eq(other),
                (I::Vdc(this, _), I::Vdc(other, _)) => this.eq(other),
                (I::VacuumBrake(this, _), I::VacuumBrake(other, _)) => this.eq(other),
                (I::Activation(this, _), I::Activation(other, _)) => this.eq(other),
                (I::Failure(this, _), I::Failure(other, _)) => this.eq(other),
                (I::Timer(this, _), I::Timer(other, _)) => this.eq(other),
                _ => false,
            }
        }
    }
    impl RuntimeInput {
        pub fn get_instant(&self) -> std::time::Instant {
            match self {
                I::Speed(_, instant) => *instant,
                I::Kickdown(_, instant) => *instant,
                I::SetSpeed(_, instant) => *instant,
                I::Vdc(_, instant) => *instant,
                I::VacuumBrake(_, instant) => *instant,
                I::Activation(_, instant) => *instant,
                I::Failure(_, instant) => *instant,
                I::Timer(_, instant) => *instant,
            }
        }
        pub fn order(v1: &Self, v2: &Self) -> std::cmp::Ordering {
            v1.get_instant().cmp(&v2.get_instant())
        }
    }
    pub enum RuntimeOutput {
        VSet(f64, std::time::Instant),
        InRegulation(bool, std::time::Instant),
        SlState(SpeedLimiterOn, std::time::Instant),
    }
    pub struct Runtime {
        speed_limiter: speed_limiter_service::SpeedLimiterService,
        timer: futures::channel::mpsc::Sender<(T, std::time::Instant)>,
    }
    impl Runtime {
        pub fn new(
            output: futures::channel::mpsc::Sender<O>,
            timer: futures::channel::mpsc::Sender<(T, std::time::Instant)>,
        ) -> Runtime {
            let speed_limiter =
                speed_limiter_service::SpeedLimiterService::init(output, timer.clone());
            Runtime {
                speed_limiter,
                timer,
            }
        }
        #[inline]
        pub async fn send_timer(
            &mut self,
            timer: T,
            instant: std::time::Instant,
        ) -> Result<(), futures::channel::mpsc::SendError> {
            self.timer.send((timer, instant)).await?;
            Ok(())
        }
        pub async fn run_loop(
            self,
            init_instant: std::time::Instant,
            input: impl futures::Stream<Item = I>,
        ) -> Result<(), futures::channel::mpsc::SendError> {
            futures::pin_mut!(input);
            let mut runtime = self;
            runtime
                .send_timer(T::PeriodSpeedLimiter, init_instant)
                .await?;
            runtime
                .send_timer(T::TimeoutSpeedLimiter, init_instant)
                .await?;
            runtime
                .send_timer(T::PeriodInRegulation, init_instant)
                .await?;
            while let Some(input) = input.next().await {
                match input {
                    I::Kickdown(kickdown, instant) => {
                        runtime
                            .speed_limiter
                            .handle_kickdown(instant, kickdown)
                            .await?;
                    }
                    I::Speed(speed, instant) => {
                        runtime.speed_limiter.handle_speed(instant, speed).await?;
                    }
                    I::SetSpeed(set_speed, instant) => {
                        runtime
                            .speed_limiter
                            .handle_set_speed(instant, set_speed)
                            .await?;
                    }
                    I::Failure(failure, instant) => {
                        runtime
                            .speed_limiter
                            .handle_failure(instant, failure)
                            .await?;
                    }
                    I::Timer(T::PeriodSpeedLimiter, instant) => {
                        runtime
                            .speed_limiter
                            .handle_period_speed_limiter(instant)
                            .await?;
                    }
                    I::Vdc(vdc, instant) => {
                        runtime.speed_limiter.handle_vdc(instant, vdc).await?;
                    }
                    I::Timer(T::TimeoutSpeedLimiter, instant) => {
                        runtime
                            .speed_limiter
                            .handle_timeout_speed_limiter(instant)
                            .await?;
                    }
                    I::Timer(T::DelaySpeedLimiter, instant) => {
                        runtime
                            .speed_limiter
                            .handle_delay_speed_limiter(instant)
                            .await?;
                    }
                    I::VacuumBrake(vacuum_brake, instant) => {
                        runtime
                            .speed_limiter
                            .handle_vacuum_brake(instant, vacuum_brake)
                            .await?;
                    }
                    I::Timer(T::PeriodInRegulation, instant) => {
                        runtime
                            .speed_limiter
                            .handle_period_in_regulation(instant)
                            .await?;
                    }
                    I::Activation(activation, instant) => {
                        runtime
                            .speed_limiter
                            .handle_activation(instant, activation)
                            .await?;
                    }
                }
            }
            Ok(())
        }
    }
    pub mod speed_limiter_service {
        use super::*;
        use futures::{sink::SinkExt, stream::StreamExt};
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct VacuumBrake(VacuumBrakeState, bool);
        impl VacuumBrake {
            fn set(&mut self, vacuum_brake: VacuumBrakeState) {
                self.0 = vacuum_brake;
                self.1 = true;
            }
            fn get(&self) -> VacuumBrakeState {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct OnState(SpeedLimiterOn, bool);
        impl OnState {
            fn set(&mut self, on_state: SpeedLimiterOn) {
                self.0 = on_state;
                self.1 = true;
            }
            fn get(&self) -> SpeedLimiterOn {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct State(SpeedLimiter, bool);
        impl State {
            fn set(&mut self, state: SpeedLimiter) {
                self.0 = state;
                self.1 = true;
            }
            fn get(&self) -> SpeedLimiter {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct VUpdate(bool, bool);
        impl VUpdate {
            fn set(&mut self, v_update: bool) {
                self.0 = v_update;
                self.1 = true;
            }
            fn get(&self) -> bool {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct X(f64, bool);
        impl X {
            fn set(&mut self, x: f64) {
                self.0 = x;
                self.1 = true;
            }
            fn get(&self) -> f64 {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct ChangedSetSpeedOld(f64, bool);
        impl ChangedSetSpeedOld {
            fn set(&mut self, changed_set_speed_old: f64) {
                self.0 = changed_set_speed_old;
                self.1 = true;
            }
            fn get(&self) -> f64 {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct VSetAux(f64, bool);
        impl VSetAux {
            fn set(&mut self, v_set_aux: f64) {
                self.0 = v_set_aux;
                self.1 = true;
            }
            fn get(&self) -> f64 {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct VSet(f64, bool);
        impl VSet {
            fn set(&mut self, v_set: f64) {
                self.0 = v_set;
                self.1 = true;
            }
            fn get(&self) -> f64 {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct InRegulationAux(bool, bool);
        impl InRegulationAux {
            fn set(&mut self, in_regulation_aux: bool) {
                self.0 = in_regulation_aux;
                self.1 = true;
            }
            fn get(&self) -> bool {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct Speed(f64, bool);
        impl Speed {
            fn set(&mut self, speed: f64) {
                self.0 = speed;
                self.1 = true;
            }
            fn get(&self) -> f64 {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct StateUpdate(bool, bool);
        impl StateUpdate {
            fn set(&mut self, state_update: bool) {
                self.0 = state_update;
                self.1 = true;
            }
            fn get(&self) -> bool {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct Vdc(VdcState, bool);
        impl Vdc {
            fn set(&mut self, vdc: VdcState) {
                self.0 = vdc;
                self.1 = true;
            }
            fn get(&self) -> VdcState {
                self.0
            }
            fn is_new(&self) -> bool {
                self.1
            }
            fn reset(&mut self) {
                self.1 = false;
            }
        }
        #[derive(Clone, Copy, PartialEq, Default)]
        pub struct Context {
            pub vacuum_brake: VacuumBrake,
            pub on_state: OnState,
            pub state: State,
            pub v_update: VUpdate,
            pub x: X,
            pub changed_set_speed_old: ChangedSetSpeedOld,
            pub v_set_aux: VSetAux,
            pub v_set: VSet,
            pub in_regulation_aux: InRegulationAux,
            pub speed: Speed,
            pub state_update: StateUpdate,
            pub vdc: Vdc,
        }
        impl Context {
            fn init() -> Context {
                Default::default()
            }
            fn reset(&mut self) {
                self.vacuum_brake.reset();
                self.on_state.reset();
                self.state.reset();
                self.v_update.reset();
                self.x.reset();
                self.changed_set_speed_old.reset();
                self.v_set_aux.reset();
                self.v_set.reset();
                self.in_regulation_aux.reset();
                self.speed.reset();
                self.state_update.reset();
                self.vdc.reset();
            }
        }
        #[derive(Default)]
        pub struct SpeedLimiterServiceStore {
            speed: Option<(f64, std::time::Instant)>,
            period_in_regulation: Option<((), std::time::Instant)>,
            kickdown: Option<(Kickdown, std::time::Instant)>,
            set_speed: Option<(f64, std::time::Instant)>,
            vdc: Option<(VdcState, std::time::Instant)>,
            vacuum_brake: Option<(VacuumBrakeState, std::time::Instant)>,
            activation: Option<(ActivationRequest, std::time::Instant)>,
            failure: Option<(Failure, std::time::Instant)>,
            period_speed_limiter: Option<((), std::time::Instant)>,
        }
        impl SpeedLimiterServiceStore {
            pub fn not_empty(&self) -> bool {
                self.speed.is_some()
                    || self.period_in_regulation.is_some()
                    || self.kickdown.is_some()
                    || self.set_speed.is_some()
                    || self.vdc.is_some()
                    || self.vacuum_brake.is_some()
                    || self.activation.is_some()
                    || self.failure.is_some()
                    || self.period_speed_limiter.is_some()
            }
        }
        pub struct SpeedLimiterService {
            context: Context,
            delayed: bool,
            input_store: SpeedLimiterServiceStore,
            speed_limiter: SpeedLimiterState,
            process_set_speed: ProcessSetSpeedState,
            output: futures::channel::mpsc::Sender<O>,
            timer: futures::channel::mpsc::Sender<(T, std::time::Instant)>,
        }
        impl SpeedLimiterService {
            pub fn init(
                output: futures::channel::mpsc::Sender<O>,
                timer: futures::channel::mpsc::Sender<(T, std::time::Instant)>,
            ) -> SpeedLimiterService {
                let context = Context::init();
                let delayed = true;
                let input_store = Default::default();
                let speed_limiter = SpeedLimiterState::init();
                let process_set_speed = ProcessSetSpeedState::init();
                SpeedLimiterService {
                    context,
                    delayed,
                    input_store,
                    speed_limiter,
                    process_set_speed,
                    output,
                    timer,
                }
            }
            pub async fn handle_speed(
                &mut self,
                speed_instant: std::time::Instant,
                speed: f64,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(speed_instant).await?;
                    self.context.reset();
                    self.context.speed.set(speed);
                } else {
                    let unique = self.input_store.speed.replace((speed, speed_instant));
                    assert!(unique.is_none(), "speed changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_period_in_regulation(
                &mut self,
                period_in_regulation_instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(period_in_regulation_instant)
                        .await?;
                    self.context.reset();
                    let in_regulation_ref = &mut None;
                    self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                        .await?;
                    *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                    if let Some(in_regulation) = *in_regulation_ref {
                        self.send_output(O::InRegulation(
                            in_regulation,
                            period_in_regulation_instant,
                        ))
                        .await?;
                    }
                } else {
                    let unique = self
                        .input_store
                        .period_in_regulation
                        .replace(((), period_in_regulation_instant));
                    assert!(
                        unique.is_none(),
                        "period_in_regulation changes too frequently"
                    );
                }
                Ok(())
            }
            pub async fn handle_timeout_speed_limiter(
                &mut self,
                timeout_speed_limiter_instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.reset_time_constraints(timeout_speed_limiter_instant)
                    .await?;
                self.context.reset();
                let (v_set_aux, v_update) = self
                    .process_set_speed
                    .step(ProcessSetSpeedInput { set_speed: None });
                self.context.v_set_aux.set(v_set_aux);
                self.context.v_update.set(v_update);
                let v_set = self.context.v_set_aux.get();
                self.context.v_set.set(v_set);
                let (state, on_state, in_regulation_aux, state_update) =
                    self.speed_limiter.step(SpeedLimiterInput {
                        vacuum_brake_state: self.context.vacuum_brake.get(),
                        vdc_disabled: self.context.vdc.get(),
                        speed: self.context.speed.get(),
                        v_set: self.context.v_set.get(),
                        activation_req: None,
                        kickdown: None,
                        failure: None,
                    });
                self.context.state.set(state);
                self.context.on_state.set(on_state);
                self.context.in_regulation_aux.set(in_regulation_aux);
                self.context.state_update.set(state_update);
                let sl_state = self.context.on_state.get();
                self.send_output(O::SlState(sl_state, timeout_speed_limiter_instant))
                    .await?;
                self.send_output(O::VSet(v_set, timeout_speed_limiter_instant))
                    .await?;
                Ok(())
            }
            #[inline]
            pub async fn reset_service_timeout(
                &mut self,
                instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.timer.send((T::TimeoutSpeedLimiter, instant)).await?;
                Ok(())
            }
            pub async fn handle_kickdown(
                &mut self,
                kickdown_instant: std::time::Instant,
                kickdown: Kickdown,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(kickdown_instant).await?;
                    self.context.reset();
                    let kickdown_ref = &mut None;
                    *kickdown_ref = Some(kickdown);
                    let (state, on_state, in_regulation_aux, state_update) =
                        self.speed_limiter.step(SpeedLimiterInput {
                            vacuum_brake_state: self.context.vacuum_brake.get(),
                            vdc_disabled: self.context.vdc.get(),
                            speed: self.context.speed.get(),
                            v_set: self.context.v_set.get(),
                            activation_req: None,
                            kickdown: *kickdown_ref,
                            failure: None,
                        });
                    self.context.state.set(state);
                    self.context.on_state.set(on_state);
                    self.context.in_regulation_aux.set(in_regulation_aux);
                    self.context.state_update.set(state_update);
                    let sl_state = self.context.on_state.get();
                    self.send_output(O::SlState(sl_state, kickdown_instant))
                        .await?;
                } else {
                    let unique = self
                        .input_store
                        .kickdown
                        .replace((kickdown, kickdown_instant));
                    assert!(unique.is_none(), "kickdown changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_set_speed(
                &mut self,
                set_speed_instant: std::time::Instant,
                set_speed: f64,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(set_speed_instant).await?;
                    self.context.reset();
                    let changed_set_speed_ref = &mut None;
                    if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                        self.context.x.set(set_speed);
                    }
                    if self.context.changed_set_speed_old.get() != self.context.x.get() {
                        self.context.changed_set_speed_old.set(self.context.x.get());
                        *changed_set_speed_ref = Some(self.context.x.get());
                    }
                    let (v_set_aux, v_update) = self.process_set_speed.step(ProcessSetSpeedInput {
                        set_speed: *changed_set_speed_ref,
                    });
                    self.context.v_set_aux.set(v_set_aux);
                    self.context.v_update.set(v_update);
                    let v_set = self.context.v_set_aux.get();
                    self.context.v_set.set(v_set);
                    self.send_output(O::VSet(v_set, set_speed_instant)).await?;
                } else {
                    let unique = self
                        .input_store
                        .set_speed
                        .replace((set_speed, set_speed_instant));
                    assert!(unique.is_none(), "set_speed changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_vdc(
                &mut self,
                vdc_instant: std::time::Instant,
                vdc: VdcState,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(vdc_instant).await?;
                    self.context.reset();
                    self.context.vdc.set(vdc);
                } else {
                    let unique = self.input_store.vdc.replace((vdc, vdc_instant));
                    assert!(unique.is_none(), "vdc changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_delay_speed_limiter(
                &mut self,
                instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.context.reset();
                if self.input_store.not_empty() {
                    self.reset_time_constraints(instant).await?;
                    match (
                        self.input_store.speed.take(),
                        self.input_store.period_in_regulation.take(),
                        self.input_store.kickdown.take(),
                        self.input_store.set_speed.take(),
                        self.input_store.vdc.take(),
                        self.input_store.vacuum_brake.take(),
                        self.input_store.activation.take(),
                        self.input_store.failure.take(),
                        self.input_store.period_speed_limiter.take(),
                    ) {
                        (None, None, None, None, None, None, None, None, None) => {}
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            self.context.vdc.set(vdc);
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            self.context.vacuum_brake.set(vacuum_brake);
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                            self.context.speed.set(speed);
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            None,
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            None,
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: None,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            None,
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let kickdown_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: None,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            None,
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            None,
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            None,
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            None,
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: None,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            None,
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            Some((speed, speed_instant)),
                            None,
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                        }
                        (
                            None,
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                        (
                            Some((speed, speed_instant)),
                            Some(((), period_in_regulation_instant)),
                            Some((kickdown, kickdown_instant)),
                            Some((set_speed, set_speed_instant)),
                            Some((vdc, vdc_instant)),
                            Some((vacuum_brake, vacuum_brake_instant)),
                            Some((activation, activation_instant)),
                            Some((failure, failure_instant)),
                            Some(((), period_speed_limiter_instant)),
                        ) => {
                            let kickdown_ref = &mut None;
                            let failure_ref = &mut None;
                            let changed_set_speed_ref = &mut None;
                            let in_regulation_ref = &mut None;
                            let activation_ref = &mut None;
                            self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                                .await?;
                            *failure_ref = Some(failure);
                            *activation_ref = Some(activation);
                            self.context.vacuum_brake.set(vacuum_brake);
                            self.context.vdc.set(vdc);
                            if (self.context.x.get() - set_speed).abs() >= 1.0f64 {
                                self.context.x.set(set_speed);
                            }
                            if self.context.changed_set_speed_old.get() != self.context.x.get() {
                                self.context.changed_set_speed_old.set(self.context.x.get());
                                *changed_set_speed_ref = Some(self.context.x.get());
                            }
                            let (v_set_aux, v_update) =
                                self.process_set_speed.step(ProcessSetSpeedInput {
                                    set_speed: *changed_set_speed_ref,
                                });
                            self.context.v_set_aux.set(v_set_aux);
                            self.context.v_update.set(v_update);
                            let v_set = self.context.v_set_aux.get();
                            self.context.v_set.set(v_set);
                            self.send_output(O::VSet(v_set, instant)).await?;
                            *kickdown_ref = Some(kickdown);
                            self.send_timer(T::PeriodInRegulation, period_in_regulation_instant)
                                .await?;
                            self.context.speed.set(speed);
                            let (state, on_state, in_regulation_aux, state_update) =
                                self.speed_limiter.step(SpeedLimiterInput {
                                    vacuum_brake_state: self.context.vacuum_brake.get(),
                                    vdc_disabled: self.context.vdc.get(),
                                    speed: self.context.speed.get(),
                                    v_set: self.context.v_set.get(),
                                    activation_req: *activation_ref,
                                    kickdown: *kickdown_ref,
                                    failure: *failure_ref,
                                });
                            self.context.state.set(state);
                            self.context.on_state.set(on_state);
                            self.context.in_regulation_aux.set(in_regulation_aux);
                            self.context.state_update.set(state_update);
                            let sl_state = self.context.on_state.get();
                            self.send_output(O::SlState(sl_state, instant)).await?;
                            *in_regulation_ref = Some(self.context.in_regulation_aux.get());
                            if let Some(in_regulation) = *in_regulation_ref {
                                self.send_output(O::InRegulation(in_regulation, instant))
                                    .await?;
                            }
                        }
                    }
                } else {
                    self.delayed = true;
                }
                Ok(())
            }
            #[inline]
            pub async fn reset_service_delay(
                &mut self,
                instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.timer.send((T::DelaySpeedLimiter, instant)).await?;
                Ok(())
            }
            pub async fn handle_vacuum_brake(
                &mut self,
                vacuum_brake_instant: std::time::Instant,
                vacuum_brake: VacuumBrakeState,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(vacuum_brake_instant).await?;
                    self.context.reset();
                    self.context.vacuum_brake.set(vacuum_brake);
                } else {
                    let unique = self
                        .input_store
                        .vacuum_brake
                        .replace((vacuum_brake, vacuum_brake_instant));
                    assert!(unique.is_none(), "vacuum_brake changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_activation(
                &mut self,
                activation_instant: std::time::Instant,
                activation: ActivationRequest,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(activation_instant).await?;
                    self.context.reset();
                    let activation_ref = &mut None;
                    *activation_ref = Some(activation);
                    let (state, on_state, in_regulation_aux, state_update) =
                        self.speed_limiter.step(SpeedLimiterInput {
                            vacuum_brake_state: self.context.vacuum_brake.get(),
                            vdc_disabled: self.context.vdc.get(),
                            speed: self.context.speed.get(),
                            v_set: self.context.v_set.get(),
                            activation_req: *activation_ref,
                            kickdown: None,
                            failure: None,
                        });
                    self.context.state.set(state);
                    self.context.on_state.set(on_state);
                    self.context.in_regulation_aux.set(in_regulation_aux);
                    self.context.state_update.set(state_update);
                    let sl_state = self.context.on_state.get();
                    self.send_output(O::SlState(sl_state, activation_instant))
                        .await?;
                } else {
                    let unique = self
                        .input_store
                        .activation
                        .replace((activation, activation_instant));
                    assert!(unique.is_none(), "activation changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_failure(
                &mut self,
                failure_instant: std::time::Instant,
                failure: Failure,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(failure_instant).await?;
                    self.context.reset();
                    let failure_ref = &mut None;
                    *failure_ref = Some(failure);
                    let (state, on_state, in_regulation_aux, state_update) =
                        self.speed_limiter.step(SpeedLimiterInput {
                            vacuum_brake_state: self.context.vacuum_brake.get(),
                            vdc_disabled: self.context.vdc.get(),
                            speed: self.context.speed.get(),
                            v_set: self.context.v_set.get(),
                            activation_req: None,
                            kickdown: None,
                            failure: *failure_ref,
                        });
                    self.context.state.set(state);
                    self.context.on_state.set(on_state);
                    self.context.in_regulation_aux.set(in_regulation_aux);
                    self.context.state_update.set(state_update);
                    let sl_state = self.context.on_state.get();
                    self.send_output(O::SlState(sl_state, failure_instant))
                        .await?;
                } else {
                    let unique = self.input_store.failure.replace((failure, failure_instant));
                    assert!(unique.is_none(), "failure changes too frequently");
                }
                Ok(())
            }
            pub async fn handle_period_speed_limiter(
                &mut self,
                period_speed_limiter_instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                if self.delayed {
                    self.reset_time_constraints(period_speed_limiter_instant)
                        .await?;
                    self.context.reset();
                    self.send_timer(T::PeriodSpeedLimiter, period_speed_limiter_instant)
                        .await?;
                    let (state, on_state, in_regulation_aux, state_update) =
                        self.speed_limiter.step(SpeedLimiterInput {
                            vacuum_brake_state: self.context.vacuum_brake.get(),
                            vdc_disabled: self.context.vdc.get(),
                            speed: self.context.speed.get(),
                            v_set: self.context.v_set.get(),
                            activation_req: None,
                            kickdown: None,
                            failure: None,
                        });
                    self.context.state.set(state);
                    self.context.on_state.set(on_state);
                    self.context.in_regulation_aux.set(in_regulation_aux);
                    self.context.state_update.set(state_update);
                    let sl_state = self.context.on_state.get();
                    self.send_output(O::SlState(sl_state, period_speed_limiter_instant))
                        .await?;
                } else {
                    let unique = self
                        .input_store
                        .period_speed_limiter
                        .replace(((), period_speed_limiter_instant));
                    assert!(
                        unique.is_none(),
                        "period_speed_limiter changes too frequently"
                    );
                }
                Ok(())
            }
            #[inline]
            pub async fn reset_time_constraints(
                &mut self,
                instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.reset_service_delay(instant).await?;
                self.reset_service_timeout(instant).await?;
                self.delayed = false;
                Ok(())
            }
            #[inline]
            pub async fn send_output(
                &mut self,
                output: O,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.output.send(output).await?;
                Ok(())
            }
            #[inline]
            pub async fn send_timer(
                &mut self,
                timer: T,
                instant: std::time::Instant,
            ) -> Result<(), futures::channel::mpsc::SendError> {
                self.timer.send((timer, instant)).await?;
                Ok(())
            }
        }
    }
}
