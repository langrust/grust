(* #"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1 *)

let%span slib0 = "/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1
let%span slib1 = "/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 12 8 27 19
let%span slib2 = "/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1

use creusot.int.Int64

use mach.int.Int

function compute_soft_braking_distance'1 [#"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1] (speed : int) : int

 =
  [%#slib0] Int.div (speed * speed) 100

use creusot.int.Int64

let rec compute_soft_braking_distance'0 (speed:Int64.t) (return'  (ret:Int64.t))= {[@expl:compute_soft_braking_distance requires] [%#slib0] 0
  <= Int64.to_int speed
  /\ Int64.to_int speed < 50}
  any
  [ return' (result:Int64.t)-> {[%#slib0] Int64.to_int result = compute_soft_braking_distance'1 (Int64.to_int speed)}
    (! return' {result}) ]


type t_Braking'0  =
  | C_UrgentBrake'0
  | C_SoftBrake'0
  | C_NoBrake'0

use creusot.prelude.Intrinsic

function brakes'1 [#"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1] (distance : int) (speed : int) : t_Braking'0

 =
  [%#slib2] let braking_distance = compute_soft_braking_distance'1 speed in let response = if braking_distance
  < distance then
    C_SoftBrake'0
  else
    C_UrgentBrake'0
   in response

meta "compute_max_steps" 1000000

let rec brakes'0[#"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1] (distance:Int64.t) (speed:Int64.t) (return'  (ret:t_Braking'0))= {[@expl:brakes requires] [%#slib0] 0
  <= Int64.to_int speed
  /\ Int64.to_int speed < 50}
  (! bb0
  [ bb0 = s0
    [ s0 = compute_soft_braking_distance'0 {speed} (fun (_ret':Int64.t) ->  [ &braking_distance <- _ret' ] s1)
    | s1 = bb1 ]
  
  | bb1 = s0
    [ s0 = Int64.lt {braking_distance} {distance} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1)
    | s1 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ]  ]
  
  | bb2 = s0 [ s0 =  [ &response <- C_SoftBrake'0 ] s1 | s1 = bb4 ] 
  | bb3 = s0 [ s0 =  [ &response <- C_UrgentBrake'0 ] s1 | s1 = bb4 ] 
  | bb4 = s0 [ s0 =  [ &_0 <- response ] s1 | s1 = return' {_0} ]  ]
  )
  [ & _0 : t_Braking'0 = Intrinsic.any_l ()
  | & distance : Int64.t = distance
  | & speed : Int64.t = speed
  | & braking_distance : Int64.t = Intrinsic.any_l ()
  | & response : t_Braking'0 = Intrinsic.any_l ()
  | & _9 : bool = Intrinsic.any_l () ]
  
  [ return' (result:t_Braking'0)-> {[@expl:brakes ensures #0] [%#slib1] result <> C_NoBrake'0}
    {[@expl:brakes ensures #1] [%#slib0] result = brakes'1 (Int64.to_int distance) (Int64.to_int speed)}
    (! return' {result}) ]
  
