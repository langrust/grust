(* #"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1 *)

(* <BrakingStateState as grust::grust_core::Component> *)

let%span slib0 = "/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1
let%span slib1 = "/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 12 8 27 19
let%span slib2 = "/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1
let%span sresolve3 = "/home/thome/Documents/git/langrust/grustine/creusot/creusot-contracts/src/resolve.rs" 54 20 54 34

use creusot.int.Int64

type t_Option'0  =
  | C_None'0
  | C_Some'0 Int64.t

type t_Option'1  =
  | C_None'1
  | C_Some'1 ()

type t_BrakingStateInput'0  =
  { t_BrakingStateInput__pedest'0: t_Option'0;
    t_BrakingStateInput__timeout_pedest'0: t_Option'1;
    t_BrakingStateInput__speed'0: Int64.t }

type t_Braking'0  =
  | C_UrgentBrake'0
  | C_SoftBrake'0
  | C_NoBrake'0

type t_BrakingStateState'0  =
  { t_BrakingStateState__last_state'0: t_Braking'0 }

let rec v_Some'0 (input:t_Option'0) (ret  (field_0:Int64.t))= any
  [ good (field_0:Int64.t)-> {C_Some'0 field_0 = input} (! ret {field_0})
  | bad -> {forall field_0 : Int64.t [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]


use creusot.int.Int64

use mach.int.Int

function compute_soft_braking_distance'0 [#"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1] (speed : int) : int

 =
  [%#slib0] Int.div (speed * speed) 100

function brakes'1 [#"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1] (distance : int) (speed : int) : t_Braking'0

 =
  [%#slib2] let braking_distance = compute_soft_braking_distance'0 speed in let response = if braking_distance
  < distance then
    C_SoftBrake'0
  else
    C_UrgentBrake'0
   in response

let rec brakes'0 (distance:Int64.t) (speed:Int64.t) (return'  (ret:t_Braking'0))= {[@expl:brakes requires] [%#slib0] 0
  <= Int64.to_int speed
  /\ Int64.to_int speed < 50}
  any
  [ return' (result:t_Braking'0)-> {[%#slib1] result <> C_NoBrake'0}
    {[%#slib0] result = brakes'1 (Int64.to_int distance) (Int64.to_int speed)}
    (! return' {result}) ]


use creusot.prelude.MutBorrow

predicate resolve'1 (self : MutBorrow.t (t_BrakingStateState'0)) =
  [%#sresolve3] self.final = self.current

predicate resolve'0 (_1 : MutBorrow.t (t_BrakingStateState'0)) =
  resolve'1 _1

use creusot.prelude.Intrinsic

meta "compute_max_steps" 1000000

let rec step'0[#"/home/thome/Documents/git/langrust/grustine/examples/aeb_greusot/src/lib.rs" 5 0 54 1] (self:MutBorrow.t (t_BrakingStateState'0)) (input:t_BrakingStateInput'0) (return'  (ret:t_Braking'0))= {[@expl:step requires] [%#slib0] 0
  <= Int64.to_int input.t_BrakingStateInput__speed'0
  /\ Int64.to_int input.t_BrakingStateInput__speed'0 < 50}
  (! bb0
  [ bb0 = s0
    [ s0 =  [ &_6 <- (input.t_BrakingStateInput__pedest'0, input.t_BrakingStateInput__timeout_pedest'0) ] s1
    | s1 = any
      [ br0 -> {(let (r'0, _) = _6 in r'0) = C_None'0 } (! bb1)
      | br1 (x0:Int64.t)-> {(let (r'0, _) = _6 in r'0) = C_Some'0 x0} (! bb2) ]
     ]
  
  | bb1 = any
    [ br0 -> {(let (_, r'0) = _6 in r'0) = C_None'1 } (! bb3)
    | br1 (x0:())-> {(let (_, r'0) = _6 in r'0) = C_Some'1 x0} (! bb4) ]
  
  | bb3 = s0 [ s0 =  [ &state <- (self.current).t_BrakingStateState__last_state'0 ] s1 | s1 = bb8 ] 
  | bb4 = bb5
  | bb5 = s0 [ s0 =  [ &state2 <- C_NoBrake'0 ] s1 | s1 =  [ &state <- state2 ] s2 | s2 = bb8 ] 
  | bb2 = bb6
  | bb6 = s0
    [ s0 = v_Some'0 {let (r'0, _) = _6 in r'0} (fun (r0'0:Int64.t) ->  [ &d <- r0'0 ] s1)
    | s1 = brakes'0 {d} {input.t_BrakingStateInput__speed'0} (fun (_ret':t_Braking'0) ->  [ &state1 <- _ret' ] s2)
    | s2 = bb7 ]
  
  | bb7 = s0 [ s0 =  [ &state <- state1 ] s1 | s1 = bb8 ] 
  | bb8 = s0
    [ s0 =  [ &self <- { self with current = { t_BrakingStateState__last_state'0 = state } } ] s1
    | s1 = -{resolve'0 self}- s2
    | s2 =  [ &_0 <- state ] s3
    | s3 = return' {_0} ]
   ]
  )
  [ & _0 : t_Braking'0 = Intrinsic.any_l ()
  | & self : MutBorrow.t (t_BrakingStateState'0) = self
  | & input : t_BrakingStateInput'0 = input
  | & state : t_Braking'0 = Intrinsic.any_l ()
  | & _6 : (t_Option'0, t_Option'1) = Intrinsic.any_l ()
  | & d : Int64.t = Intrinsic.any_l ()
  | & state1 : t_Braking'0 = Intrinsic.any_l ()
  | & state2 : t_Braking'0 = Intrinsic.any_l () ]
  
  [ return' (result:t_Braking'0)-> {[@expl:step ensures] [%#slib0] forall p : Int64.t . C_Some'0 p
    = input.t_BrakingStateInput__pedest'0  -> result <> C_NoBrake'0}
    (! return' {result}) ]
  
