use crate::ast::{
    user_defined_type::UserDefinedType,
    function::Function,
    node::Node,
    component::Component,
    file::File,
};
use crate::util::location::Location;
use crate::util::files::FileId;

grammar(file_id: FileId);

/// Catches types definition
pub userTypes: UserDefinedType = {
    // catches enumerations definition
    <start:@L> "enum" <end:@R> => {
        UserDefinedType::Enumeration {
            location: Location{ file_id, range: start..end },
        }
    },
    // catches structure definition
    <start:@L> "struct" <end:@R> => {
        UserDefinedType::Structure {
            location: Location{ file_id, range: start..end },
        }
    },
    // catches array definition
    <start:@L> "array" <end:@R> => {
        UserDefinedType::Array {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches function
pub function: Function = {
    <start:@L> "function" <end:@R> => {
        Function {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches node
pub node: Node = {
    <start:@L> "node" <end:@R> => {
        Node {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches component
pub component: Component = {
    <start:@L> "component" <end:@R> => {
        Component {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches LanGRust modules
pub module: File = {
    // a module composed of one function
    <start:@L> <f: function> <end:@R> =>  File::Module{
        functions: vec![f],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one node
    <start:@L> <n: node> <end:@R> =>  File::Module{
        functions: vec![],
        nodes: vec![n],
        location: Location{ file_id, range: start..end }
    },
    // adds a function to a module
    <start:@L> <mut m: module> <f: function> <end:@R> => {
        m.push_function(f);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a node to a module
    <start:@L> <mut m: module> <n: node> <end:@R> => {
        m.push_node(n);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
}

/// Catches LanGRust programs
pub program: File = {
    // a program composed of one component
    <start:@L> <c: component> <end:@R> => File::Program{
        functions: vec![],
        nodes: vec![],
        component: c,
        location: Location{ file_id, range: start..end }
    },
    // adds a component to a module, this returns a program
    <start:@L> <m: module> <c: component> <end:@R> =>  {
        let (functions, nodes) = m.get_functions_nodes();
        File::Program{
            functions,
            nodes,
            component: c,
            location: Location{ file_id, range: start..end }
        }
    },
    // adds a function to a program
    <start:@L> <mut p: program> <f: function> <end:@R> => {
        p.push_function(f);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a node to a program
    <start:@L> <mut p: program> <n: node> <end:@R> => {
        p.push_node(n);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
}

/// Catches LanGRust files
pub file: File = {
    // catches a module
    <m: module> => m,
    // catches a program
    <p: program> => p,
}