use std::str::FromStr;

use crate::ast::{
    calculus::Calculus,
    component::Component,
    constant::Constant,
    equation::Equation,
    expression::Expression,
    file::File,
    function::Function,
    location::Location,
    node::Node,
    operator::{UnaryOperator, BinaryOperator, OtherOperator},
    pattern::Pattern,
    scope::Scope,
    stream_expression::StreamExpression,
    type_system::Type,
    user_defined_type::UserDefinedType,
};

grammar(file_id: usize);

/// Skip whitespaces and comments.
match {
    r"\s*" => { },                              // skip whitespaces
    r"//[^\n\r]*[\n\r]*" => { },                // skip line comments `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },   // skip block comments `/* comments */`
} else {
    _                                           // else return the string
}

/// Creates vectors of key/value pairs from "k : v, ..., k : v" patterns
hash<K, V>: Vec<(K, V)> = {
    <mut h: (<K> ":" <V> ",")*> <k: K> ":" <v: V> ","? => {
        h.push((k, v));
        h
    }
};
/// Creates lists of elements T from "t, ..., t" patterns
list<T>: Vec<T> = {
    <mut v: (<T> ",")*> <t: T> ","? => {
        v.push(t);
        v
    }
};

/// Catches identifiers
ID: String = {
    r"\w*[a-zA-Z_]\w*" => String::from(<>),
};

/// Catches basic types
pub basicType: Type = {
    "int" => Type::Integer,
    "float" => Type::Float,
    "bool" => Type::Boolean,
    "string" => Type::String,
    "unit" => Type::Unit,
    "[" <t: basicType> ";" <n: r"\d+"> "]" => Type::Array(
        Box::new(t),
        usize::from_str(n).unwrap()
    ),
    <t: basicType> "?" => Type::Option(Box::new(t)),
    <id:ID> => Type::NotDefinedYet(id),
};

/// Catches signals' scopes
scope: Scope = {
    <"out"?> => match <> {
        Some(_) => Scope::Output,
        None => Scope::Local,
    },
};

/// Catches constants
pub constant: Constant = {
    "()" => Constant::Unit,
    "true" => Constant::Boolean(true),
    "false" => Constant::Boolean(false),
    r#""[^"]*""# => {
        let mut s = <>.to_string();
        s.pop();            // remove last
        if s.len() > 0 {
            s.remove(0);    // remove first
        }
        Constant::String(s)
    },
    r"\d+\.\d+" => Constant::Float(f64::from_str(<>).unwrap()),
    r"\d+" => Constant::Integer(i64::from_str(<>).unwrap()),
    <enumeration:ID>"."<elem:ID> => Constant::Enumeration(enumeration, elem)
};

/// Catches unary operator
unaryOperator: UnaryOperator = {
    "-" => UnaryOperator::Neg,
    "!" => UnaryOperator::Not,
};
/// Catches multiplication and division
firstBinaryOperator: BinaryOperator = {
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
};
/// Catches addition and subtraction
secondBinaryOperator: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
};
/// Catches comparators
thirdBinaryOperator: BinaryOperator = {
    "==" => BinaryOperator::Eq,
    "!=" => BinaryOperator::Dif,
    ">=" => BinaryOperator::Geq,
    "<=" => BinaryOperator::Leq,
    ">" => BinaryOperator::Grt,
    "<" => BinaryOperator::Low,
};
/// Catches logical operator
fourthBinaryOperator: BinaryOperator = {
    "&&" => BinaryOperator::And,
    "||" => BinaryOperator::Or,
};

/// Catches patterns
pub pattern: Pattern = {
    // catches identifier pattern
    <start:@L> <name: ID> <end:@R> => {
        Pattern::Identifier {
            name, 
            location: Location{ file_id, range: start..end }
        }
    },
    // catches constant pattern
    <start:@L> <c: constant> <end:@R> => {
        Pattern::Constant {
            constant: c, 
            location: Location{ file_id, range: start..end }
        }
    },
    // catches strcuture patterns
    <start:@L> <name: ID> "{" <fields: hash<ID, pattern>> "}" <end:@R> => {
        Pattern::Structure {
            name,
            fields,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches optional patterns with value
    <start:@L> "some(" <p: pattern> ")" <end:@R> => {
        Pattern::Some {
            pattern: Box::new(p),
            location: Location{ file_id, range: start..end }
        }
    },
    // catches optional patterns without value
    <start:@L> "none" <end:@R> => {
        Pattern::None {
            location: Location{ file_id, range: start..end }
        }
    },
    // catches the default patterns
    <start:@L> "_" <end:@R> => {
        Pattern::Default {
            location: Location{ file_id, range: start..end }
        }
    },
};
/// Catches matching arms
arm<E>: (Pattern, Option<E>, E) = {
    <pattern> <("if" <E>)?> "=>" <E> => (<>)
};

/// Catches terms as expressions
term: Expression = {
    // catches constant as expressions
    <start:@L> <c: constant> <end:@R> => {
        Expression::Constant {
            constant: c,
            typing: None,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches element call as expressions
    <start:@L> <id: ID> <end:@R> => {
        Expression::Call{
            id,
            typing: None,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches brackets as expressions
    <start:@L> "(" <e: expression> ")" <end:@R> => {
        Expression::Application {
            function_expression: Box::new(Expression::Call{
                id: UnaryOperator::Brackets.to_string(),
                typing: None,
                location: Location{ file_id, range: start..end }
            }),
            inputs: vec![e],
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches function applications as expressions
    <start:@L> <fun_name: ID> <end_fun:@R> "(" <v_expr: list<expression>> ")" <end:@R> => {
        Expression::Application {
            function_expression: Box::new(Expression::Call {
                id: fun_name,
                typing: None,
                location: Location{ file_id, range: start..end_fun }
            }),
            inputs: v_expr,
            typing: None,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches pattern matching as expressions
    <start:@L> "match" "(" <expr: expression> ")" "{"
    <v_arm: list<arm<expression>>> "}" <end:@R> => {
        Expression::Match {
            expression: Box::new(expr),
            arms: v_arm,
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches print applications as expressions
    <start:@L> "print" "(" <e: expression> ")" <end:@R> => {
        Expression::Application {
            function_expression: Box::new(Expression::Call {
                id: OtherOperator::Print.to_string(),
                typing: None,
                location: Location{ file_id, range: start..end }
            }),
            inputs: vec![e],
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches structure definition as expressions
    <start:@L> <name: ID> "{" <fields: hash<ID, expression>> "}" <end:@R> => {
        Expression::Structure {
            name,
            fields,
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches array definition as expressions
    <start:@L> "[" <v_expr: list<expression>> "]" <end:@R> => {
        Expression::Array {
            elements: v_expr,
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches unified array definition as expressions
    <start:@L> "[" <e: expression> ";" <n: r"\d+"> "]" <end:@R> => {
        Expression::Array {
            elements: vec![e; usize::from_str(n).unwrap()],
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
};

/// Catches unary operations as expression first or a term
unaryExpression: Expression = {
    <start:@L> <start_op:@L> <op: unaryOperator> <end_op:@R> <e: term> <end:@R> => {
        Expression::Application {
            function_expression: Box::new(Expression::Call {
                id: op.to_string(),
                typing: None,
                location: Location{ file_id, range: start_op..end_op }
            }),
            inputs: vec![e],
            typing: None,
            location: Location{ file_id, range: start..end },
        }
    },
    term,
};

/// Helper for binary operations. Tries to parse a binary operation
/// of form `E Op E`, otherwise parses an expression of form `E`.
auxBinaryExpression<Op,E>: Expression = {
    <start:@L> <e1: auxBinaryExpression<Op,E>> <start_op:@L> <op: Op> <end_op:@R><e2: E> <end:@R> => {
        Expression::Application{
            function_expression: Box::new(Expression::Call{
                id: op.to_string(),
                typing: None,
                location: Location{ file_id, range: start_op..end_op }
            }),
            inputs: vec![e1, e2],
            typing: None,
            location: Location{ file_id, range: start..end },
        }
    },
    E,
};
/// Catches binary operations as stream expressions
firstBinaryExpression: Expression = auxBinaryExpression<firstBinaryOperator, unaryExpression>;
secondBinaryExpression: Expression = auxBinaryExpression<secondBinaryOperator, firstBinaryExpression>;
thirdBinaryExpression: Expression = auxBinaryExpression<thirdBinaryOperator, secondBinaryExpression>;
fourthBinaryExpression: Expression = auxBinaryExpression<fourthBinaryOperator, thirdBinaryExpression>;

/// Catches all LanGrust expressions
pub expression: Expression = {
    // catches if_then_else as expressions
    <start:@L> "if" <e1: expression> "then" <e2: expression>
    "else" <e3: expression> <end:@R> => {
        Expression::Application {
            function_expression: Box::new(Expression::Call {
                id: OtherOperator::IfThenElse.to_string(),
                typing: None,
                location: Location{ file_id, range: start..end }
            }),
            inputs: vec![e1, e2, e3],
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches when_then_else as expressions
    <start:@L> "when" <start_id:@L> <id: ID> <end_id:@R> <e1: ("=" <expression>)?>
    "then" <e2: expression> "else" <e3: expression> <end:@R> => {
        Expression::When {
            id: id.clone(),
            option: match e1 {
                Some(e1) => Box::new(e1),
                None => Box::new(Expression::Call {
                    id,
                    typing: None,
                    location: Location{ file_id, range: start_id..end_id }
                })
            },
            present: Box::new(e2),
            default: Box::new(e3),
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches abstractions as expressions
    <start:@L> "|" <ids: list<ID>> "|" <e: expression> <end:@R> => {
        Expression::Abstraction {
            inputs: ids,
            expression: Box::new(e),
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches typed abstractions as expressions
    <start:@L> "|" <ids: hash<ID, basicType>> "|" <e: expression> <end:@R> => {
        Expression::TypedAbstraction {
            inputs: ids,
            expression: Box::new(e),
            typing: None,
            location: Location{ file_id, range: start..end }
        }
    },
    fourthBinaryExpression,
};

/// Catches calculus line
pub calculus: Calculus = {
    <start:@L> "let" <id: ID> ":" <t: basicType> "=" <e: expression> ";" <end:@R> => {
        Calculus {
            id,
            element_type: t,
            expression: e,
            location: Location{ file_id, range: start..end }
        }
    }
}

/// Catches terms as stream expressions
streamTerm: StreamExpression = {
    // catches constant as stream expressions
    <start:@L> <c: constant> <end:@R> => {
        StreamExpression::Constant {
            constant: c,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches signal call as stream expressions
    <start:@L> <id: ID> <end:@R> => {
        StreamExpression::SignalCall{
            id,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches brackets as stream expressions
    <start:@L> "(" <e: streamExpression> ")" <end:@R> => {
        StreamExpression::MapApplication {
            function_expression: Expression::Call{
                id: UnaryOperator::Brackets.to_string(),
                typing: None,
                location: Location{ file_id, range: start..end }
            },
            inputs: vec![e],
            location: Location{ file_id, range: start..end }
        }
    },
    // catches map applications as stream expressions
    <start:@L> "(" <v_expr: list<streamExpression>> ").map" "(" <f: expression> ")" <end:@R> => {
        StreamExpression::MapApplication {
            function_expression: f,
            inputs: v_expr,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches node applications as stream expressions
    <start:@L> <node: ID> "(" <v_expr: list<streamExpression>> ")" "." <signal: ID> <end:@R> => {
        StreamExpression::NodeApplication {
            node,
            inputs: v_expr,
            signal,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches pattern matching as stream expressions
    <start:@L> "match" "(" <expr: streamExpression> ")" "{"
    <v_arm: list<arm<streamExpression>>> "}" <end:@R> => {
        StreamExpression::Match {
            expression: Box::new(expr),
            arms: v_arm,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches print applications as stream expressions
    <start:@L> "print" "(" <e: streamExpression> ")" <end:@R> => {
        StreamExpression::MapApplication {
            function_expression: Expression::Call {
                id: OtherOperator::Print.to_string(),
                typing: None,
                location: Location{ file_id, range: start..end }
            },
            inputs: vec![e],
            location: Location{ file_id, range: start..end }
        }
    },
    // catches structure definition as stream expressions
    <start:@L> <name: ID> "{" <fields: hash<ID, streamExpression>> "}" <end:@R> => {
        StreamExpression::Structure {
            name,
            fields,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches array definition as stream expressions
    <start:@L> "[" <v_expr: list<streamExpression>> "]" <end:@R> => {
        StreamExpression::Array {
            elements: v_expr,
            location: Location{ file_id, range: start..end }
        }
    },
    // catches unified array definition as stream expressions
    <start:@L> "[" <e: streamExpression> ";" <n: r"\d+"> "]" <end:@R> => {
        StreamExpression::Array {
            elements: vec![e; usize::from_str(n).unwrap()],
            location: Location{ file_id, range: start..end }
        }
    },
};

/// Catches unary operations as stream expression first or a term
unaryStreamExpression: StreamExpression = {
    <start:@L> <start_op:@L> <op: unaryOperator> <end_op:@R> <e: streamTerm> <end:@R> => {
        StreamExpression::MapApplication {
            function_expression: Expression::Call {
                id: op.to_string(),
                typing: None,
                location: Location{ file_id, range: start_op..end_op }
            },
            inputs: vec![e],
            location: Location{ file_id, range: start..end },
        }
    },
    streamTerm,
};

/// Helper for binary operations. Tries to parse a binary operation
/// of form `E Op E`, otherwise parses a stream expression of form `E`.
auxBinaryStreamExpression<Op,E>: StreamExpression = {
    <start:@L> <e1: auxBinaryStreamExpression<Op,E>> <start_op:@L> <op: Op> <end_op:@R> <e2: E> <end:@R> => {
        StreamExpression::MapApplication{
            function_expression: Expression::Call{
                id: op.to_string(),
                typing: None,
                location: Location{ file_id, range: start_op..end_op }
            },
            inputs: vec![e1, e2],
            location: Location{ file_id, range: start..end },
        }
    },
    E,
};
/// Catches binary operations as stream expressions
firstBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<firstBinaryOperator, unaryStreamExpression>;
secondBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<secondBinaryOperator, firstBinaryStreamExpression>;
thirdBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<thirdBinaryOperator, secondBinaryStreamExpression>;
fourthBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<fourthBinaryOperator, thirdBinaryStreamExpression>;

/// Catches all LanGrust stream expressions
pub streamExpression: StreamExpression = {
    // catches initialized buffers as stream expressions
    <start:@L> <c: constant> "fby" <e: streamExpression> <end:@R> => {
        StreamExpression::FollowedBy {
            constant: c,
            expression: Box::new(e),
            location: Location{ file_id, range: start..end }
        }
    },
    // catches if_then_else as stream expressions
    <start:@L> "if" <e1: streamExpression> "then" <e2: streamExpression>
    "else" <e3: streamExpression> <end:@R> => {
        StreamExpression::MapApplication {
            function_expression: Expression::Call {
                id: OtherOperator::IfThenElse.to_string(),
                typing: None,
                location: Location{ file_id, range: start..end }
            },
            inputs: vec![e1, e2, e3],
            location: Location{ file_id, range: start..end }
        }
    },
    // catches when_then_else as stream expressions
    <start:@L> "when" <start_id:@L> <id: ID> <end_id:@R> <e1: ("=" <streamExpression>)?>
    "then" <e2: streamExpression> "else" <e3: streamExpression> <end:@R> => {
        StreamExpression::When {
            id: id.clone(),
            option: match e1 {
                Some(e1) => Box::new(e1),
                None => Box::new(StreamExpression::SignalCall {
                    id,
                    location: Location{ file_id, range: start_id..end_id }
                })
            },
            present: Box::new(e2),
            default: Box::new(e3),
            location: Location{ file_id, range: start..end }
        }
    },
    fourthBinaryStreamExpression,
};

/// Catches equation
pub equation: Equation = {
    <start:@L> <s: scope> <id: ID> ":" <t: basicType> "=" <e: streamExpression> ";" <end:@R> => {
        Equation {
            scope: s,
            id,
            signal_type: t,
            expression: e,
            location: Location{ file_id, range: start..end }
        }
    }
}

/// Catches type definition
pub userType: UserDefinedType = {
    // catches enumerations definition
    <start:@L> "enum" <id: ID> "{" <elements: list<ID>> "}" <end:@R> => {
        UserDefinedType::Enumeration {
            id,
            elements,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches structure definition
    <start:@L> "struct" <id: ID> "{" <fields: hash<ID, basicType>> "}" <end:@R> => {
        UserDefinedType::Structure {
            id,
            fields,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches array definition
    <start:@L> "array" <id: ID> "[" <t: basicType> ";" <n: r"\d+"> "]" <end:@R> => {
        UserDefinedType::Array {
            id,
            array_type: t,
            size: usize::from_str(n).unwrap(),
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches function
pub function: Function = {
    <start:@L> "function" <n: ID> "(" <i: hash<ID, basicType>> ")" "->" <t: basicType> "{" <c: calculus*> "return" <e: expression> ";" "}" <end:@R> => {
        Function {
            id: n,
            inputs: i,
            calculi: c.into_iter().map(|calculus| (calculus.id.clone(), calculus)).collect(),
            returned: (t, e),
            location: Location{ file_id, range: start..end },
        }
    },
    <start:@L> "function" <n: ID> "()" "->" <t: basicType> "{" <c: calculus*> "return" <e: expression> ";" "}" <end:@R> => {
        Function {
            id: n,
            inputs: vec![],
            calculi: c.into_iter().map(|calculus| (calculus.id.clone(), calculus)).collect(),
            returned: (t, e),
            location: Location{ file_id, range: start..end },
        }
    }
};

/// Catches node
pub node: Node = {
    <start:@L> "node" <n: ID> "(" <i: hash<ID, basicType>> ")" "{" <e: equation+> "}" <end:@R> => {
        Node {
            id: n,
            inputs: i,
            equations: e.into_iter().map(|equation| (equation.id.clone(), equation)).collect(),
            location: Location{ file_id, range: start..end },
        }
    },
    <start:@L> "node" <n: ID> "()" "{" <e: equation+> "}" <end:@R> => {
        Node {
            id: n,
            inputs: vec![],
            equations: e.into_iter().map(|equation| (equation.id.clone(), equation)).collect(),
            location: Location{ file_id, range: start..end },
        }
    }
};

/// Catches component
pub component: Component = {
    <start:@L> "component" <c: ID> "(" <i: hash<ID, basicType>> ")" "{" <e: equation+> "}" <end:@R> => {
        Component {
            id: c,
            inputs: i,
            equations: e.into_iter().map(|equation| (equation.id.clone(), equation)).collect(),
            location: Location{ file_id, range: start..end },
        }
    },
    <start:@L> "component" <c: ID> "()" "{" <e: equation+> "}" <end:@R> => {
        Component {
            id: c,
            inputs: vec![],
            equations: e.into_iter().map(|equation| (equation.id.clone(), equation)).collect(),
            location: Location{ file_id, range: start..end },
        }
    }
};

/// Catches LanGRust modules
pub module: File = {
    // a module composed of one type
    <start:@L> <t: userType> <end:@R> =>  File::Module{
        user_defined_types: vec![t],
        functions: vec![],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one function
    <start:@L> <f: function> <end:@R> =>  File::Module{
        user_defined_types: vec![],
        functions: vec![f],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one node
    <start:@L> <n: node> <end:@R> =>  File::Module{
        user_defined_types: vec![],
        functions: vec![],
        nodes: vec![n],
        location: Location{ file_id, range: start..end }
    },
    // adds a type definition to a module
    <start:@L> <mut m: module> <t: userType> <end:@R> => {
        m.push_type(t);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a function to a module
    <start:@L> <mut m: module> <f: function> <end:@R> => {
        m.push_function(f);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a node to a module
    <start:@L> <mut m: module> <n: node> <end:@R> => {
        m.push_node(n);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
}

/// Catches LanGRust programs
pub program: File = {
    // a program composed of one component
    <start:@L> <c: component> <end:@R> => File::Program{
        user_defined_types: vec![],
        functions: vec![],
        nodes: vec![],
        component: c,
        location: Location{ file_id, range: start..end }
    },
    // adds a component to a module, this returns a program
    <start:@L> <m: module> <c: component> <end:@R> =>  {
        let (user_defined_types, functions, nodes) = m.get_types_functions_nodes();
        File::Program{
            user_defined_types,
            functions,
            nodes,
            component: c,
            location: Location{ file_id, range: start..end }
        }
    },
    // adds a type definition to a program
    <start:@L> <mut p: program> <t: userType> <end:@R> => {
        p.push_type(t);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a function to a program
    <start:@L> <mut p: program> <f: function> <end:@R> => {
        p.push_function(f);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a node to a program
    <start:@L> <mut p: program> <n: node> <end:@R> => {
        p.push_node(n);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
}

/// Catches LanGRust files
pub file: File = {
    // catches a module
    <m: module> => m,
    // catches a program
    <p: program> => p,
}