use std::str::FromStr;

use crate::ast::{
    expression::Expression,
    stream_expression::StreamExpression,
    user_defined_type::UserDefinedType,
    function::Function,
    node::Node,
    component::Component,
    file::File,
};
use crate::util::operator::{UnaryOperator, BinaryOperator, OtherOperator};
use crate::util::constant::Constant;
use crate::util::type_system::Type;
use crate::util::location::Location;
use crate::util::files::FileId;

grammar(file_id: FileId);

/// Creates vectors of key/value pairs from "k : v, ..., k : v" patterns
hash<K, V>: Vec<(K, V)> = {
    <mut h: (<K> ":" <V> ",")*> <k: K> ":" <v: V> ","? => {
        h.push((k, v));
        h
    }
};
/// Creates lists of elements T from "t, ..., t" patterns
list<T>: Vec<T> = {
    <mut v: (<T> ",")*> <t: T> ","? => {
        v.push(t);
        v
    }
};

/// Catches identifiers
ID: String = {
    r"\w*[a-zA-Z_]\w*" => String::from(<>),
};

/// Catches basic types
pub basicType: Type = {
    "int" => Type::Integer,
    "float" => Type::Float,
    "bool" => Type::Boolean,
    "string" => Type::String,
    "unit" => Type::Unit,
    "[" <t: basicType> ";" <n: r"\d+"> "]" => Type::Array(
        Box::new(t),
        usize::from_str(n).unwrap()
    ),
    <t: basicType> "?" => Type::Option(Box::new(t)),
    <id:ID> => Type::NotDefinedYet(id),
};

/// Catches constants
pub constant: Constant = {
    "()" => Constant::Unit,
    "true" => Constant::Boolean(true),
    "false" => Constant::Boolean(false),
    r#""[^"]*""# => {
        let mut s = <>.to_string();
        s.pop();            // remove last
        if s.len() > 0 {
            s.remove(0);    // remove first
        }
        Constant::String(s)
    },
    r"\d+\.\d+" => Constant::Float(f64::from_str(<>).unwrap()),
    r"\d+" => Constant::Integer(i64::from_str(<>).unwrap()),
    <enumeration:ID>"."<elem:ID> => Constant::Enumeration(enumeration, elem)
};

/// Catches unary operator
unaryOperator: UnaryOperator = {
    "-" => UnaryOperator::Neg,
    "!" => UnaryOperator::Not,
};
/// Catches multiplication and division
firstBinaryOperator: BinaryOperator = {
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
};
/// Catches addition and subtraction
secondBinaryOperator: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
};
/// Catches comparators
thirdBinaryOperator: BinaryOperator = {
    "==" => BinaryOperator::Eq,
    "!=" => BinaryOperator::Dif,
    ">=" => BinaryOperator::Geq,
    "<=" => BinaryOperator::Leq,
    ">" => BinaryOperator::Grt,
    "<" => BinaryOperator::Low,
};
/// Catches logical operator
fourthBinaryOperator: BinaryOperator = {
    "&&" => BinaryOperator::And,
    "||" => BinaryOperator::Or,
};

/// Catches terms as expressions
term: Expression = {
    // catches constant as expressions
    <start:@L> <c: constant> <end:@R> => {
        Expression::Constant {
            constant: c,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches element call as expressions
    <start:@L> <id: ID> <end:@R> => {
        Expression::Call{
            id,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches brackets as expressions
    <start:@L> "(" <e: expression> ")" <end:@R> => {
        Expression::Application {
            expression: Box::new(Expression::Call{
                id: UnaryOperator::Brackets.to_string(),
                location: Location{ file_id, range: start..end }
            }),
            inputs: vec![e],
            location: Location{ file_id, range: start..end }
        }
    },
    // catches function applications as expressions
    <start:@L> <fun_name: ID> <end_fun:@R> "(" <v_expr: list<expression>> ")" <end:@R> => {
        Expression::Application {
            expression: Box::new(Expression::Call {
                id: fun_name,
                location: Location{ file_id, range: start..end_fun }
            }),
            inputs: v_expr,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches print applications as expressions
    <start:@L> "print" "(" <e: expression> ")" <end:@R> => {
        Expression::Application {
            expression: Box::new(Expression::Call {
                id: OtherOperator::Print.to_string(),
                location: Location{ file_id, range: start..end }
            }),
            inputs: vec![e],
            location: Location{ file_id, range: start..end }
        }
    },
};

/// Catches unary operations as expression first or a term
unaryExpression: Expression = {
    <start:@L> <start_op:@L> <op: unaryOperator> <end_op:@R> <e: term> <end:@R> => {
        Expression::Application {
            expression: Box::new(Expression::Call {
                id: op.to_string(),
                location: Location{ file_id, range: start_op..end_op }
            }),
            inputs: vec![e],
            location: Location{ file_id, range: start..end },
        }
    },
    term,
};

/// Helper for binary operations. Tries to parse a binary operation
/// of form `E Op E`, otherwise parses an expression of form `E`.
auxBinaryExpression<Op,E>: Expression = {
    <start:@L> <e1: auxBinaryExpression<Op,E>> <start_op:@L> <op: Op> <end_op:@R> <e2: E> <end:@R> => {
        Expression::Application{
            expression: Box::new(Expression::Call{
                id: op.to_string(),
                location: Location{ file_id, range: start_op..end_op }
            }),
            inputs: vec![e1, e2],
            location: Location{ file_id, range: start..end },
        }
    },
    E,
};
/// Catches binary operations as stream expressions
firstBinaryExpression: Expression = auxBinaryExpression<firstBinaryOperator, unaryExpression>;
secondBinaryExpression: Expression = auxBinaryExpression<secondBinaryOperator, firstBinaryExpression>;
thirdBinaryExpression: Expression = auxBinaryExpression<thirdBinaryOperator, secondBinaryExpression>;
fourthBinaryExpression: Expression = auxBinaryExpression<fourthBinaryOperator, thirdBinaryExpression>;

/// Catches all LanGrust expressions
pub expression: Expression = {
    // catches if_then_else as expressions
    <start:@L> "if" <e1: expression> "then" <e2: expression> "else" <e3: expression> <end:@R> => {
        Expression::Application {
            expression: Box::new(Expression::Call {
                id: OtherOperator::IfThenElse.to_string(),
                location: Location{ file_id, range: start..end }
            }),
            inputs: vec![e1, e2, e3],
            location: Location{ file_id, range: start..end }
        }
    },
    // catches abstractions as expressions
    <start:@L> "|" <ids: list<ID>> "|" <e: expression> <end:@R> => {
        Expression::Abstraction {
            inputs: ids,
            expression: Box::new(e),
            location: Location{ file_id, range: start..end }
        }
    },
    // catches typed abstractions as expressions
    <start:@L> "|" <ids: hash<ID, basicType>> "|" <e: expression> <end:@R> => {
        Expression::TypedAbstraction {
            inputs: ids,
            expression: Box::new(e),
            location: Location{ file_id, range: start..end }
        }
    },
    fourthBinaryExpression,
};

/// Catches terms as stream expressions
streamTerm: StreamExpression = {
    // catches constant as stream expressions
    <start:@L> <c: constant> <end:@R> => {
        StreamExpression::Constant {
            constant: c,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches signal call as stream expressions
    <start:@L> <id: ID> <end:@R> => {
        StreamExpression::SignalCall{
            id,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches brackets as stream expressions
    <start:@L> "(" <e: streamExpression> ")" <end:@R> => {
        StreamExpression::MapApplication {
            expression: Expression::Call{
                id: UnaryOperator::Brackets.to_string(),
                location: Location{ file_id, range: start..end }
            },
            inputs: vec![e],
            location: Location{ file_id, range: start..end }
        }
    },
    // catches map applications as stream expressions
    <start:@L> "(" <v_expr: list<streamExpression>> ").map" "(" <f: expression> ")" <end:@R> => {
        StreamExpression::MapApplication {
            expression: f,
            inputs: v_expr,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches print applications as stream expressions
    <start:@L> "print" "(" <e: streamExpression> ")" <end:@R> => {
        StreamExpression::MapApplication {
            expression: Expression::Call {
                id: OtherOperator::Print.to_string(),
                location: Location{ file_id, range: start..end }
            },
            inputs: vec![e],
            location: Location{ file_id, range: start..end }
        }
    },
};

/// Catches unary operations as stream expression first or a term
unaryStreamExpression: StreamExpression = {
    <start:@L> <start_op:@L> <op: unaryOperator> <end_op:@R> <e: streamTerm> <end:@R> => {
        StreamExpression::MapApplication {
            expression: Expression::Call {
                id: op.to_string(),
                location: Location{ file_id, range: start_op..end_op }
            },
            inputs: vec![e],
            location: Location{ file_id, range: start..end },
        }
    },
    streamTerm,
};

/// Helper for binary operations. Tries to parse a binary operation
/// of form `E Op E`, otherwise parses a stream expression of form `E`.
auxBinaryStreamExpression<Op,E>: StreamExpression = {
    <start:@L> <e1: auxBinaryStreamExpression<Op,E>> <start_op:@L> <op: Op> <end_op:@R> <e2: E> <end:@R> => {
        StreamExpression::MapApplication{
            expression: Expression::Call{
                id: op.to_string(),
                location: Location{ file_id, range: start_op..end_op }
            },
            inputs: vec![e1, e2],
            location: Location{ file_id, range: start..end },
        }
    },
    E,
};
/// Catches binary operations as stream expressions
firstBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<firstBinaryOperator, unaryStreamExpression>;
secondBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<secondBinaryOperator, firstBinaryStreamExpression>;
thirdBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<thirdBinaryOperator, secondBinaryStreamExpression>;
fourthBinaryStreamExpression: StreamExpression = auxBinaryStreamExpression<fourthBinaryOperator, thirdBinaryStreamExpression>;

/// Catches all LanGrust stream expressions
pub streamExpression: StreamExpression = {
    // catches if_then_else as stream expressions
    <start:@L> "if" <e1: streamExpression> "then" <e2: streamExpression> "else" <e3: streamExpression> <end:@R> => {
        StreamExpression::MapApplication {
            expression: Expression::Call {
                id: OtherOperator::IfThenElse.to_string(),
                location: Location{ file_id, range: start..end }
            },
            inputs: vec![e1, e2, e3],
            location: Location{ file_id, range: start..end }
        }
    },
    fourthBinaryStreamExpression,
};

/// Catches type definition
pub userType: UserDefinedType = {
    // catches enumeration definition
    <start:@L> "enum" <end:@R> => {
        UserDefinedType::Enumeration {
            location: Location{ file_id, range: start..end },
        }
    },
    // catches structure definition
    <start:@L> "struct" <end:@R> => {
        UserDefinedType::Structure {
            location: Location{ file_id, range: start..end },
        }
    },
    // catches array definition
    <start:@L> "array" <end:@R> => {
        UserDefinedType::Array {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches function
pub function: Function = {
    <start:@L> "function" <end:@R> => {
        Function {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches node
pub node: Node = {
    <start:@L> "node" <end:@R> => {
        Node {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches component
pub component: Component = {
    <start:@L> "component" <end:@R> => {
        Component {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches LanGRust modules
pub module: File = {
    // a module composed of one type
    <start:@L> <t: userType> <end:@R> =>  File::Module{
        user_defined_types: vec![t],
        functions: vec![],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one function
    <start:@L> <f: function> <end:@R> =>  File::Module{
        user_defined_types: vec![],
        functions: vec![f],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one node
    <start:@L> <n: node> <end:@R> =>  File::Module{
        user_defined_types: vec![],
        functions: vec![],
        nodes: vec![n],
        location: Location{ file_id, range: start..end }
    },
    // adds a type definition to a module
    <start:@L> <mut m: module> <t: userType> <end:@R> => {
        m.push_type(t);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a function to a module
    <start:@L> <mut m: module> <f: function> <end:@R> => {
        m.push_function(f);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a node to a module
    <start:@L> <mut m: module> <n: node> <end:@R> => {
        m.push_node(n);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
}

/// Catches LanGRust programs
pub program: File = {
    // a program composed of one component
    <start:@L> <c: component> <end:@R> => File::Program{
        user_defined_types: vec![],
        functions: vec![],
        nodes: vec![],
        component: c,
        location: Location{ file_id, range: start..end }
    },
    // adds a component to a module, this returns a program
    <start:@L> <m: module> <c: component> <end:@R> =>  {
        let (user_defined_types, functions, nodes) = m.get_types_functions_nodes();
        File::Program{
            user_defined_types,
            functions,
            nodes,
            component: c,
            location: Location{ file_id, range: start..end }
        }
    },
    // adds a type definition to a program
    <start:@L> <mut p: program> <t: userType> <end:@R> => {
        p.push_type(t);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a function to a program
    <start:@L> <mut p: program> <f: function> <end:@R> => {
        p.push_function(f);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a node to a program
    <start:@L> <mut p: program> <n: node> <end:@R> => {
        p.push_node(n);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
}

/// Catches LanGRust files
pub file: File = {
    // catches a module
    <m: module> => m,
    // catches a program
    <p: program> => p,
}