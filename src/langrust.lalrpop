use std::str::FromStr;

use crate::ast::{
    expression::Expression,
    stream_expression::StreamExpression,
    user_defined_type::UserDefinedType,
    function::Function,
    node::Node,
    component::Component,
    file::File,
};
use crate::util::operator::{UnaryOperator, BinaryOperator};
use crate::util::constant::Constant;
use crate::util::type_system::Type;
use crate::util::location::Location;
use crate::util::files::FileId;

grammar(file_id: FileId);

/// Catches identifiers
ID: String = {
    r"\w*[a-zA-Z_]\w*" => String::from(<>),
};

/// Catches basic types
pub basicType: Type = {
    "int" => Type::Integer,
    "float" => Type::Float,
    "bool" => Type::Boolean,
    "string" => Type::String,
    "unit" => Type::Unit,
    "[" <t: basicType> ";" <n: r"\d+"> "]" => Type::Array(
        Box::new(t),
        usize::from_str(n).unwrap()
    ),
    <t: basicType> "?" => Type::Option(Box::new(t)),
    <id:ID> => Type::NotDefinedYet(id),
};

/// Catches constants
pub constant: Constant = {
    "()" => Constant::Unit,
    "true" => Constant::Boolean(true),
    "false" => Constant::Boolean(false),
    r#""[^"]*""# => {
        let mut s = <>.to_string();
        s.pop();            // remove last
        if s.len() > 0 {
            s.remove(0);    // remove first
        }
        Constant::String(s)
    },
    r"\d+\.\d+" => Constant::Float(f64::from_str(<>).unwrap()),
    r"\d+" => Constant::Integer(i64::from_str(<>).unwrap()),
    <enumeration:ID>"."<elem:ID> => Constant::Enumeration(enumeration, elem)
};

/// Catches unary operator
unaryOperator: UnaryOperator = {
    "-" => UnaryOperator::Neg,
    "!" => UnaryOperator::Not,
};
/// Catches multiplication and division
firstBinaryOperator: BinaryOperator = {
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
};
/// Catches addition and subtraction
secondBinaryOperator: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
};
/// Catches comparators
thirdBinaryOperator: BinaryOperator = {
    "==" => BinaryOperator::Eq,
    "!=" => BinaryOperator::Dif,
    ">=" => BinaryOperator::Geq,
    "<=" => BinaryOperator::Leq,
    ">" => BinaryOperator::Grt,
    "<" => BinaryOperator::Low,
};
/// Catches logical operator
fourthBinaryOperator: BinaryOperator = {
    "&&" => BinaryOperator::And,
    "||" => BinaryOperator::Or,
};

/// Catches terms as expressions
pub term: Expression = {
    // catches constant as expressions
    <start:@L> <c: constant> <end:@R> => {
        Expression::Constant {
            constant: c,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches element call as expressions
    <start:@L> <id: ID> <end:@R> => {
        Expression::Call{
            id,
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Helper for binary operations. Tries to parse a binary operation
/// of form `E Op E`, otherwise parses an expression of form `E`.
auxBinaryExpression<Op,E>: Expression = {
    <start:@L> <e1: auxBinaryExpression<Op,E>> <start_op:@L> <op: Op> <end_op:@R> <e2: E> <end:@R> => {
        Expression::Application{
            expression: Box::new(Expression::Call{
                id: op.to_string(),
                location: Location{ file_id, range: start_op..end_op }
            }),
            inputs: vec![e1, e2],
            location: Location{ file_id, range: start..end },
        }
    },
    E,
};

/// Catches terms as stream expressions
pub streamTerm: StreamExpression = {
    // catches constant as stream expressions
    <start:@L> <c: constant> <end:@R> => {
        StreamExpression::Constant {
            constant: c,
            location: Location{ file_id, range: start..end },
        }
    },
    // catches signal call as stream expressions
    <start:@L> <id: ID> <end:@R> => {
        StreamExpression::SignalCall{
            id,
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Helper for binary operations. Tries to parse a binary operation
/// of form `E Op E`, otherwise parses a stream expression of form `E`.
auxBinaryStreamExpression<Op,E>: StreamExpression = {
    <start:@L> <e1: auxBinaryExpression<Op,E>> <start_op:@L> <op: Op> <end_op:@R> <e2: E> <end:@R> => {
        StreamExpression::MapApplication{
            expression: Box::new(Expression::Call{
                id: op.to_string(),
                location: Location{ file_id, range: start_op..end_op }
            }),
            inputs: vec![e1, e2],
            location: Location{ file_id, range: start..end },
        }
    },
    E,
};

/// Catches type definition
pub userType: UserDefinedType = {
    // catches enumeration definition
    <start:@L> "enum" <end:@R> => {
        UserDefinedType::Enumeration {
            location: Location{ file_id, range: start..end },
        }
    },
    // catches structure definition
    <start:@L> "struct" <end:@R> => {
        UserDefinedType::Structure {
            location: Location{ file_id, range: start..end },
        }
    },
    // catches array definition
    <start:@L> "array" <end:@R> => {
        UserDefinedType::Array {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches function
pub function: Function = {
    <start:@L> "function" <end:@R> => {
        Function {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches node
pub node: Node = {
    <start:@L> "node" <end:@R> => {
        Node {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches component
pub component: Component = {
    <start:@L> "component" <end:@R> => {
        Component {
            location: Location{ file_id, range: start..end },
        }
    },
};

/// Catches LanGRust modules
pub module: File = {
    // a module composed of one type
    <start:@L> <t: userType> <end:@R> =>  File::Module{
        user_defined_types: vec![t],
        functions: vec![],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one function
    <start:@L> <f: function> <end:@R> =>  File::Module{
        user_defined_types: vec![],
        functions: vec![f],
        nodes: vec![],
        location: Location{ file_id, range: start..end }
    },
    // a module composed of one node
    <start:@L> <n: node> <end:@R> =>  File::Module{
        user_defined_types: vec![],
        functions: vec![],
        nodes: vec![n],
        location: Location{ file_id, range: start..end }
    },
    // adds a type definition to a module
    <start:@L> <mut m: module> <t: userType> <end:@R> => {
        m.push_type(t);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a function to a module
    <start:@L> <mut m: module> <f: function> <end:@R> => {
        m.push_function(f);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
    // adds a node to a module
    <start:@L> <mut m: module> <n: node> <end:@R> => {
        m.push_node(n);
        m.set_location(Location{ file_id, range: start..end });
        m
    },
}

/// Catches LanGRust programs
pub program: File = {
    // a program composed of one component
    <start:@L> <c: component> <end:@R> => File::Program{
        user_defined_types: vec![],
        functions: vec![],
        nodes: vec![],
        component: c,
        location: Location{ file_id, range: start..end }
    },
    // adds a component to a module, this returns a program
    <start:@L> <m: module> <c: component> <end:@R> =>  {
        let (user_defined_types, functions, nodes) = m.get_types_functions_nodes();
        File::Program{
            user_defined_types,
            functions,
            nodes,
            component: c,
            location: Location{ file_id, range: start..end }
        }
    },
    // adds a type definition to a program
    <start:@L> <mut p: program> <t: userType> <end:@R> => {
        p.push_type(t);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a function to a program
    <start:@L> <mut p: program> <f: function> <end:@R> => {
        p.push_function(f);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
    // adds a node to a program
    <start:@L> <mut p: program> <n: node> <end:@R> => {
        p.push_node(n);
        p.set_location(Location{ file_id, range: start..end });
        p
    },
}

/// Catches LanGRust files
pub file: File = {
    // catches a module
    <m: module> => m,
    // catches a program
    <p: program> => p,
}