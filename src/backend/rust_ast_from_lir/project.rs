use std::{
    collections::BTreeMap,
    path::{Path, PathBuf},
};

use crate::{
    backend::rust_ast_from_lir::item::{
        array_alias::rust_ast_from_lir as array_alias_rust_ast_from_lir,
        enumeration::rust_ast_from_lir as enumeration_rust_ast_from_lir,
        function::rust_ast_from_lir as function_rust_ast_from_lir,
        node_file::rust_ast_from_lir as node_file_rust_ast_from_lir,
        structure::rust_ast_from_lir as structure_rust_ast_from_lir,
    },
    lir::{item::Item, project::Project},
};
use proc_macro2::Span;
use syn::*;

#[derive(Debug)]
/// Rust project resulting from compiling.
pub struct RustASTProject {
    /// Project's directory.
    pub directory: String,
    files: BTreeMap<String, File>,
}
impl RustASTProject {
    fn new() -> Self {
        RustASTProject {
            files: Default::default(),
            directory: Default::default(),
        }
    }

    fn add_file(&mut self, path: &str, file: File) {
        self.files.insert(path.to_owned(), file);
    }

    /// Set project's directory.
    pub fn set_parent<P>(&mut self, path: P)
    where
        P: AsRef<std::path::Path>,
    {
        let subdirectory = std::mem::take(&mut self.directory);
        self.directory = path
            .as_ref()
            .join(subdirectory)
            .into_os_string()
            .into_string()
            .unwrap();
    }

    /// Generate Rust project.
    pub fn generate(&self) {
        let base = PathBuf::from(&self.directory);
        for (path, file) in &self.files {
            generate_file(&base, path, file)
        }
        self.generate_cargo();
        self.generate_gitignore();
    }

    fn generate_cargo(&self) {
        let project_name = std::path::Path::new(&self.directory)
            .file_stem()
            .unwrap()
            .to_str()
            .unwrap();
        let file_string = format!(
            "[package]
name = \"{project_name}\"
version = \"0.1.0\"
edition = \"2021\"
authors = [\"Émilie THOMÉ <emilie.e.thome@renault.com>\"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
"
        );
        let path = std::path::Path::new(&self.directory).join("Cargo.toml");

        if let Some(p) = AsRef::<std::path::Path>::as_ref(&path).parent() {
            std::fs::create_dir_all(p).unwrap()
        };
        std::fs::write(path, file_string).unwrap();
    }

    fn generate_gitignore(&self) {
        let file_string = "# Rust ignores
#=============
# Compiled files
*.o
*.so
*.rlib
*.dll

# Executables
*.exe

# Generated by Cargo
/target

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here http://doc.crates.io/guide.html#cargotoml-vs-cargolock
Cargo.lock

# VScode settings
/.vscode
";
        let path = std::path::Path::new(&self.directory).join(".gitignore");

        if let Some(p) = AsRef::<std::path::Path>::as_ref(&path).parent() {
            std::fs::create_dir_all(p).unwrap()
        };
        std::fs::write(path, file_string).unwrap();
    }
}

fn generate_file(base: &Path, path: &str, file: &File) {
    let pretty_file = prettyplease::unparse(&file);

    let path = base.join(path);
    if let Some(p) = path.parent() {
        std::fs::create_dir_all(p).unwrap()
    };
    std::fs::write(path, pretty_file).unwrap();
}
/// Transform LIR item into RustAST item.
pub fn rust_ast_from_lir(project: Project) -> RustASTProject {
    let mut rust_ast_project = RustASTProject::new();

    let mut function_file = File {
        shebang: None,
        items: Default::default(),
        attrs: vec![],
    };
    let mut typedefs_file = File {
        shebang: None,
        items: Default::default(),
        attrs: vec![],
    };

    project.items.into_iter().for_each(|item| match item {
        Item::NodeFile(node_file) => {
            let (path, rust_ast_node_file) = node_file_rust_ast_from_lir(node_file);
            rust_ast_project.add_file(&path, rust_ast_node_file)
        }
        Item::Function(function) => {
            let mut rust_ast_function = function_rust_ast_from_lir(function);
            function_file.items.append(&mut rust_ast_function)
        }
        Item::Enumeration(enumeration) => {
            let rust_ast_enumeration = enumeration_rust_ast_from_lir(enumeration);
            typedefs_file
                .items
                .push(syn::Item::Enum(rust_ast_enumeration))
        }
        Item::Structure(structure) => {
            let rust_ast_structure = structure_rust_ast_from_lir(structure);
            typedefs_file
                .items
                .push(syn::Item::Struct(rust_ast_structure))
        }
        Item::ArrayAlias(array_alias) => {
            let rust_ast_array_alias = array_alias_rust_ast_from_lir(array_alias);
            typedefs_file
                .items
                .push(syn::Item::Type(rust_ast_array_alias))
        }
    });

    rust_ast_project.add_file("src/functions.rs", function_file);
    rust_ast_project.add_file("src/typedefs.rs", typedefs_file);

    let mut lib_file = File {
        shebang: None,
        items: Default::default(),
        attrs: vec![],
    };
    rust_ast_project.files.iter().for_each(|(path, _)| {
        let module_name = Path::new(&path)
            .file_stem()
            .unwrap()
            .to_str()
            .unwrap()
            .to_string();
        let module_ident = Ident::new(&module_name, Span::call_site());
        let module_decl = parse_quote! { pub mod #module_ident; };
        lib_file.items.push(syn::Item::Mod(module_decl))
    });
    rust_ast_project.add_file("src/lib.rs", lib_file);

    rust_ast_project
}
