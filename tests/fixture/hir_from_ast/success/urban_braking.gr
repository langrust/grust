enum Braking {
    NoBrake,
    SoftBrake,
    UrgentBrake
}

function brakes(distance: float, speed: float) -> float {
    let d: float = speed * 0.278 ; // distance for 1 second at speed
    return if d < distance
           then Braking::SoftBrake
           else Braking::UrgentBrake;
}
component braking_state(pedest: float?, speed: float)
    requires { 0.0 <= speed && speed < 50.0 }  // urban limit
    // ensures  { pedest? => state != Braking::NoBrake } // safety
{
    out state: Braking = when d = pedest
                         then brakes(d, speed)
                         else previous_state;
    previous_state: Braking = Braking::NoBrake fby state;
/* initial equation:
    out state: Braking =
        when d = pedest? then brakes(d, speed)
        timeout Braking::NoBrake else previous_state;   */
}
interface urban_braking {
    import signal float car.speed_km_h;
    import event  float car.detect.left.pedestrian  as l; // in meters
    import event  float car.detect.right.pedestrian as r; // in meters

    event float pedestrian = timeout(merge(l, r), 500);
    signal Braking brakes = braking_state(pedestrian, speed_km_h).state;
    
    export car.urban.braking.brakes;
}
