speed toutes les 10ms
80 < speed < 120 pendant 1s => level 1 (mise à jour de l'état)
120 < speed pendant 1s => level 2 (mise à jour de l'état)



enum Alert { Level0, Level1, Level2 }

node over_speed_alert(speed: int, dt: int) {
	out alert: Alert = if (80 < speed < 120) && (t_level >= 1000)
		then Alert::Level1
		else if (120 <= speed) && (t_level >= 1000)
			then Alert::Level2
			else Alert::Level0;
			
	t_level: int = 0 fby if change then dt else t + dt;
	
	prev_alert: Alert = Alert::Level0 fby alert;
	change: bool = prev_alert != alert;
}



Timeout checks :
les signaux/event arrivent à des fréquences minimales
=> on annote les noeuds sur les fréquences des inputs et outputs avec des clauses timing
=> on calcule pour voir si c'est cohérent (avec des messages d'aide
   au sampling si les fréquences ne correspondent pas)
=> on vérifie au runtime (aux inputs du système) que c'est effectivement vrai

Les preuves CREUSOT :
si on prouve les propriétés
=> on enlève les check runtimes de panic
on veut des assertions (et idem si on les prouve)


MIRI pour le code unsafe

operateur 'sample' pour faire des calculs en scan

node test(
	signal i1: int @ 1Hz,
	event  i2: int every 10ms,
) -> {
	o: int,
	z: int,
}
	CONTRACTS
{
	EQUATIONS
}

component main() {
	{o, z} = test(a, b);
}

